<!DOCTYPE html>
<html lang="en">
<head>
    <!-- add mocha css, to show results -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/3.2.0/mocha.css">
    <!-- add mocha framework code -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/3.2.0/mocha.js"></script>
    <script>
        mocha.setup('bdd'); // minimal setup
    </script>
    <!-- add chai -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/3.5.0/chai.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sinon.js/15.2.0/sinon.min.js"></script>

    <script>
        // chai has a lot of stuff, let's make assert global
        let assert = chai.assert;

    </script>
    <title>Data types tests</title>
</head>
<body>
<script>

    function readNumber(message) {
        let number = prompt(message, 0);
        if (isNaN(number) || (!number & number !== 0)) {
            return readNumber(message);
        }
        return +number;
    }

    function randomNumber(min, max) {
        return (Math.random() * (max - min) + min);
    }

    function randomInt(min, max) {
        return Math.floor(randomNumber(min, max + 1));
    }

    function checkSpam(str) {
        let lowerStr = str.toLowerCase();
        return lowerStr.includes('viagra') || lowerStr.includes('xxx');
    }

    let truncate = (str, maxLength) => (str.length > maxLength) ? str.slice(0, maxLength - 1) + '...' : str;

    function extractCurrencyValue(str) {
        return +str.slice(1)
    }

    function getMaxSubSum(arr) {
        let maxSum = 0;
        let partialSum = 0;
        for (let item of arr) {
            partialSum += item;
            maxSum = Math.max(maxSum, partialSum);
            if (partialSum < 0) partialSum = 0;
        }
        return maxSum;
    }

    function camelize(str) {
        let result = '';

        for (let i = 0; i < str.length; i++) {
            if (str[i] === '-' && i !== str.length - 1) {
                ++i;
                result += str[i].toUpperCase();
            } else {
                result += str[i];
            }
        }
        return result
    }

    function camelizeV2(str) {
        let split = str.split('-');
        let result = '';
        let i = 0;
        for (let item of split) {
            if (item !== '-' && i++ !== 0) {
                result += item[0].toUpperCase() + item.slice(1);
            } else {
                result += item;
            }
        }
        return result;
    }

    function camelizeMap(str) {
        return str.split('-').map((str, index) => index === 0 ? str : str[0].toUpperCase() + str.slice(1)).join('');
    }

    function filterRange(arr, a, b) {
        return arr.filter(item => (a <= item && item <= b));
    }

    function filterRangeInPlace(arr, a, b) {
        for (let i = 0; i < arr.length; i++) {
            let val = arr[i];
            if (val < a || val > b) {
                arr.splice(i, 1);
                i--;
            }
        }
    }

    let copySorted = arr => arr.slice().sort()

    function Calculator() {

        this.methods = {
            '-': (a, b) => a - b,
            '+': (a, b) => a + b,
        };

        this.addMethod = (name, func) => {
            name = name.trim();
            this.methods[name] = func;
        };

        this._getMethodName = str => {
            for (const method in this.methods) {
                if (str.includes(method)) return method;
            }
        }

        this.calculate = str => {
            let method = this._getMethodName(str);
            let split = str.split(method),
                a = split[0],
                b = split[1];
            if (!method || isNaN(a) || isNaN(b)) return NaN;
            return this.methods[method](+a, +b);
        };
    }

    function shuffle(arr) {
        // does this work the same as Fisher-Yates shuffle?
        for (let i = 0; i < arr.length; i++) {
            let tmp = arr[i];
            let randomIndex = randomInt(i, arr.length - 1);
            arr[i] = arr[randomIndex];
            arr[randomIndex] = tmp;
        }
    }

    let unique = (arr) => {
        let set = {};
        for (let item of arr) {
            set[item] = true;
        }
        return Array.from(Object.keys(set));
    }

    let groupById = (arr) => {
        return arr.reduce((acc, item) => {
            acc[item.id] = item;
            return acc;
        }, {});
    }

    let topSalary = (salaries) => {
        let max = 0;
        let maxName = null;
        for (const [name, salary] of Object.entries(salaries)) {
            if (salary > max) {
                max = salary;
                maxName = name;
            }
        }
        return maxName;
    }



</script>
<script src="data_types/test_datatypes.js"></script>
<div id="mocha"></div>
<!-- run tests! -->
<script> mocha.run(); </script>
</body>
</html>