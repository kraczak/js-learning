<!DOCTYPE html>
<html lang="en">
<head>
    <!-- add mocha css, to show results -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/3.2.0/mocha.css">
    <!-- add mocha framework code -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/3.2.0/mocha.js"></script>
    <script>
        mocha.setup('bdd'); // minimal setup
    </script>
    <!-- add chai -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/3.5.0/chai.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sinon.js/15.2.0/sinon.min.js"></script>

    <script>
        // chai has a lot of stuff, let's make assert global
        let assert = chai.assert;

    </script>
    <title>Advanced functions</title>
</head>
<body>

<script>
    function recursivePow(a, n) {
        if (n < 0) return recursivePow(1 / a, -n);
        if (n === 0) return 1;
        return (n === 1) ? a : a * recursivePow(a, n - 1);
    }

    function recursiveSumSalaries(obj) {
        if (Array.isArray(obj)) {
            return obj.reduce((prev, current) => prev + current.salary, 0);
        } else {
            let sum = 0;
            for (let subDepartment of Object.values(obj)) {
                sum += recursiveSumSalaries(subDepartment);
            }
            return sum;
        }
    }

    let sumTo = a => (a === 0) ? 0 : a + sumTo(a - 1);
    let mathSumTo = a => (a + 1) * a / 2;

    let factorial = n => (n <= 1) ? 1 : n * factorial(n - 1);
    let fibonacci = n => n <= 1 ? n : fibonacci(n - 2) + fibonacci(n - 1)

    let listToArray = list => (!list.next) ? [list.value] : [list.value].concat(listToArray(list.next));
    let reverseListToArray = list => (!list.next) ? [list.value] : reverseListToArray(list.next).concat([list.value]);


    let listToArrayLoop = list => {
        let reference = list;
        let result = [];
        while (reference) {
            result.push(reference.value);
            reference = reference.next;
        }
        return result;
    };

    let reversedListToArrayLoop = list => {
        let reference = list;
        let result = [];
        while (reference) {
            result.push(reference.value);
            reference = reference.next;
        }
        return result.reverse();
    };

    // closures with arrow functions are pretty
    let sum = (a) => b => a + b;

    function sumV2(a) {
        return function (b) {
            return a + b;
        }
    }

    let inBetween = (a, b) => x => (x >= a && x <= b);

    function inBetweenV2(a, b) {
        return function (x) {
            return (x >= a && x <= b);
        }
    }

    let inArray = args => x => args.includes(x);

    function inArrayV2(args) {
        return function (x) {
            return args.includes(x);
        }
    }

    // not necessarily nice solution, but wanted to have some fun
    function fibonacciV2(n) {

        if (n <= 1) return n;

        let first = fibonacciV2.map.get(Math.max(0, n - 2)) || fibonacciV2(n - 3) + fibonacciV2(n - 4)
        let second = fibonacciV2.map.get(Math.max(0, n - 1)) || fibonacciV2(n - 2) + fibonacciV2(n - 3)
        let result = first + second;
        fibonacciV2.map.set(n, result)

        return result;
    }

    fibonacciV2.map = new Map();
    fibonacciV2.map.set(0, 0)
    fibonacciV2.map.set(1, 1)


    function makeCounter() {
        let count = 0;

        function counter() {
            return ++count;
        }

        counter.set = value => count = value;
        counter.decrease = () => --count;

        return counter;
    }

    function funnySum(a) {
        let sum = a;

        function add(value) {
            sum += value;
            return add;
        }

        add.valueOf = () => `${sum}`;
        return add;
    }

    // does not see variables in current scope, only the globals
    let notSafeSum = new Function('a', 'b', 'return a + b');
    new Function('a', 'b', 'return a + b'); // basic syntax
    new Function('a,b', 'return a + b'); // comma-separated
    new Function('a , b', 'return a + b'); // comma-separated with spaces

    async function sayHi(phrase, who) {
        if (who === 'lol') {
            console.log('waiting for 1 sec')
            await new Promise(r => setTimeout(r, 10000));
        }
        alert(phrase + ', ' + who);
    }

    function printNumbersTimeout(from, to) {
        let current = from;
        setTimeout(function go() {
            console.log(`${current} at ${Date.now()}`)
            if (current < to) {
                setTimeout(go, 100)
            }
            current++;
        }, 100);
    }

    function printNumbersInterval(from, to) {
        let current = from;
        let intervalId = setInterval(function go() {
            console.log(`${current} at ${Date.now()}`)
            if (current === to) {
                clearInterval(intervalId);
            }
            current++;
        }, 100);
    }

    // printNumbersTimeout(5, 10);
    // printNumbersInterval(5, 10);
    let hash = (...args) => args.join(',');
    function cachingDecorator(func) {
        let cache = new Map();

        return function(...args) {
            let key = hash(args);
            if (cache.has(key)) {
                return cache.get(key);
            }
            let result = func.call(this, ...args);
            // alternatively we could use apply method, which is faster but works only for array-like args
            // let result = func.apply(this, args);
            cache.set(key, result);
            return result
        }
    }

    let worker = {
        someMethod() {
            return 1;
        },

        slow(min, max) {
            console.log(`Called with (${min}, ${max})` );
            return min + max;
        }
    };

    worker.slow = cachingDecorator(worker.slow); // now make it caching

    console.log( worker.slow(2, 2) ); // works
    console.log( worker.slow(2, 2) );

    function spy(func) {
        let calcHash = (args) => args.join(',');
        function wrapper(...args) {
            let hash = calcHash(args);
            wrapper.calls[hash] = ++wrapper.calls[hash] || 1;
            return func.apply(this, args);
        }
        wrapper.calls = new Map();
        return wrapper;
    }

    function delay(func, ms) {
        return function() {
            setTimeout(() => func.apply(this, arguments), ms)
        }
    }

    function debounce(func, ms){
        // runs function at most once every [ms] and returns value for last arguments
        // it delays execution by [ms] every time a function is called and runs it with the last argument
        let lastCalled;
        return function() {
            clearTimeout(lastCalled);
            lastCalled = setTimeout(() => func.apply(this, arguments), ms)
        }
    }

    function throttle(func, ms) {
        // it allows to run function func only once every ms
        // if function is called during "throttle" time it will be run after "throttle" time expires, with last arguments
        let isThrottled = false,
            savedArgs,
            savedThis;
        function wrapper() {
            if (isThrottled) {
                savedArgs = arguments;
                savedThis = this;
                return;
            }
            isThrottled = true;

            console.log(func.apply(this, arguments));

            setTimeout(() => {
                isThrottled = false;
                if (savedArgs) {
                    wrapper.apply(savedThis, savedArgs);
                    savedArgs = savedThis = null;
                }
            }, ms);
        }
        return wrapper;
    }

    // function binding
    function mul(a, b) {
        return a * b;
    }
    // in this example works pretty the same as partial function in Python
    let double = mul.bind(null, 2);

    function partial(func, ...argsBound) {
        // if we wanted to make a partial that works for methods
        return function(...args) {
            return func.call(this, ...argsBound, ...args);
        }
    }

    let user = {
        firstName: "John",
        say(time, phrase) {
            console.log(`[${time}] ${this.firstName}: ${phrase}!`);
        }
    };

    // add a partial method with fixed time
    user.sayNow = partial(user.say, new Date().getHours() + ':' + new Date().getMinutes());
    user.sayNow("Lol");

    function askPassword(ok, fail) {
        let password = prompt("Password?", '');
        if (password == "rockstar") ok();
        else fail();
    }

    user = {
        name: 'John',

        loginOk() {
            alert(`${this.name} logged in`);
        },

        loginFail() {
            alert(`${this.name} failed to log in`);
        },

    };

    askPassword(user.loginOk.bind(user), user.loginFail.bind(user));


</script>

<script src="advanced-functions/testAdvancedFunctions.js"></script>
<div id="mocha"></div>
<!-- run tests! -->
<script> mocha.run(); </script>
</body>
</html>